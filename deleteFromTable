#!/usr/bin/bash


# â”€â”€â”€ ANSI Colors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[1;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color



dbName=$1
dbPath="./mydb/$dbName"

# List tables (excluding metadata)
tables=($(ls "$dbPath" | grep -v '^\.' | grep -v '\.metadata$'))
if [[ ${#tables[@]} -eq 0 ]]; then
  echo -e "\n${RED}[Error] âŒ No tables in '$dbName'.${NC}"
  read -n1 -r -p $'\nğŸ”™ Press any key to return to the table menu...' key
  exit 1
fi

# Let user select a table (with a "Cancel" option)
options=( "${tables[@]}" "Cancel" )

echo -e "${BLUE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo -e "${CYAN}[Info] ğŸ“‹ Available Tables in '$dbName'${NC}"
echo -e "${BLUE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
PS3="ğŸ“Œ Enter your choice (1-${#options[@]}): "
select tableName in "${options[@]}"; do
  case "$tableName" in
    "Cancel")
      echo -e "${YELLOW}[Info] ğŸ”™ Returning to Menu...${NC}"
      exit 0
      ;;
    "")
      # Out of range or nonâ€‘numeric
      echo -e "${YELLOW}[Warning]âš ï¸  Invalid selection. Please try again.${NC}"
      ;;
    *)
      tablePath="$dbPath/$tableName"
      metaFile="$dbPath/.${tableName}.metadata"

      if [[ ! -f "$tablePath" ]]; then
         echo -e "${RED}[Error] âŒ Table file '$tableName' not found. Try again.${NC}"
      elif [[ ! -f "$metaFile" ]]; then
         echo -e "${RED}[Error] âŒ Metadata for '$tableName' not found. Try again.${NC}"
      else
        # valid selection
        break
      fi
      ;;
  esac
done

# Load column names into array
metaCols=($(cut -d":" -f1 "$metaFile"))
metaTypes=($(cut -d":" -f2 "$metaFile"))


while true; do

  # Show full table
  echo -e "\nğŸ“‚ ${CYAN} Selected table: $tableName${NC}"

  # Check for empty table file
  if [[ ! -s "$tablePath" ]]; then
    echo -e "${YELLOW}[Warning] âš ï¸  Table file is empty.${NC}"
    read -r -p 'Press any key to return to menu ...' -n1 -s
    exit 0
  fi


  echo -e "${BLUE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo -e "${CYAN}[Info] ğŸ“Š Content of Table $tableName${NC}"
  echo -e "${BLUE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
  {
    echo "${metaCols[*]}" | tr ' ' ':'
    cat "$tablePath"
  } | column -t -s ":"


  # Choose column
  while true; do
  
  read -p "Enter column name to filter, or '*' to delete ALL rows, or '0' to exit): " col

  # If user wants to clear the entire table:
  if [[ "$col" == "*" ]]; then
  read -p 'Type "SURE" to confirm: ' confirm

    if [[ "$confirm" == "SURE" ]]; then
       > "$tablePath"
       # > "$metaFile"
       read -r -p "All rows deleted from table '$tableName'."  -n1 -s
       exit 0
    else
      echo -e "${YELLOW}âš ï¸  To confirm deletion, type 'SURE'.${NC}"
      continue
    fi
  fi

  
  if [[ "$col" == "0" ]]; then
    echo "${YELLOW}[Info] ğŸ”™ Returning to menu."
    exit 0
  fi

  if [[ -z "$col" ]]; then
  echo -e "${YELLOW}[Warning] âš ï¸  No input entered. Please try again.${NC}"
  continue
  fi

  idx=-1
  for i in "${!metaCols[@]}"; do
    if [[ "${metaCols[$i]}" == "$col" ]]; then
      idx=$((i+1))
      break
    fi
  done

  if (( idx == -1 )); then
    echo -e "${RED}[Error] âŒ Column '$col' not found. Try again.${NC}"
  else
    colType=${metaTypes[$((idx-1))]}
    break
  fi
 done

 # Numeric vs string/boolean handling
  if [[ "$colType" == "INT" ]]; then
    numericCol=true
  else
    numericCol=false
    echo -e "${CYAN}[Info] â„¹ï¸  Note: Type of column '$col' is '$colType'; only '=' comparisons allowed.${NC}"
  fi

# Choose operator
  if $numericCol; then
    echo; echo -e "${BLUE}ğŸ“ Choose a comparison operator (or Cancel to exit):${NC}"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    ops=( "=" "!=" ">" "<" ">=" "<=" "Cancel" )
    PS3="ğŸ”¢ Enter your choice (1-${#ops[@]}): "
    select choice in "${ops[@]}"; do
      case $REPLY in
        1) op="=="   ;;  
        2) op="!="   ;;  
        3) op=">"    ;;  
        4) op="<"    ;;  
        5) op=">="   ;;  
        6) op="<="   ;;  
        7) echo -e "${YELLOW}[Info] ğŸ”™ Exiting...${NC}"; exit 0 ;;
        *) echo -e "${YELLOW}[Warning] âš ï¸  Invalid selection. Try again.${NC}"; continue ;;
      esac
      break
    done
  else
    op="=="
  fi


 # Read comparison value
  while true; do
    read -p "âœï¸  Enter value for '$col' (or 0 to exit): " val
    if [[ -z "$val" ]]; then
      echo -e "${YELLOW}[Warning] âš ï¸  No input entered. Try again.${NC}"
      continue
    elif [[ "$val" == "0" ]]; then
      echo -e "${YELLOW}[Info] ğŸ”™ Exiting...${NC}"
      exit 0
    fi
    if $numericCol && ! [[ "$val" =~ ^-?[0-9]+(\.[0-9]+)?$ ]]; then
      echo -e "${RED}[Error] âŒ '$val' is not a valid number. Try again.${NC}"
      continue
    fi
    break
  done

  # awk to select only matching rows
    result=$(awk -v c="$idx" -v v="$val" '
    BEGIN {
      FS = ":"
    }
    # For each line where field c compared to v, print the line
    { 
      if ($c '"$op"' v) 
      print
    }' "$tablePath")

    if [[ -z "$result" ]]; then
    echo -e "${YELLOW}[Info] ğŸ” No matching records found.${NC}"
    read -r -p "Press any key to try again..." -n1 -s
    continue
    fi

    # build new table without those rows
      newTable=$(awk -v c="$idx" -v v="$val" '
      BEGIN { FS=OFS = ":" }
      {
        if (! ($c '"$op"' v) )
          print
      }
      ' "$tablePath")


      # overwrite the table
      echo "$newTable" > "$tablePath"
      echo -e "${GREEN}[Success]âœ… Deleted rows where $col = '$val'.${NC}"
    
     {
       echo "${metaCols[*]}" | tr ' ' ':'
       echo "$result"
     } | column -t -s ":"
    
     # Show updated table:
     echo -e "\n${CYAN}[Info] ğŸ“‹ Updated content of $tableName:${NC}"
     echo -e "${BLUE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
     {
       echo "${metaCols[*]}" | tr ' ' ':'
       echo "$newTable"
     } | column -t -s ":"
     read -r -p "Press any key to try again..." -n1 -s
     break
    

  clear

done
